<!doctype html>
<html lang="eng">
<head>
  <title>Handwriting recognition algorithm JavaScript | Machine Learning</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fetch/2.0.1/fetch.min.js"></script>
  <script src="/handwriting/math.js"></script>
  <style>
    #writingGrid {
      width: 100%;
      max-width: 500px;
      margin: 50px auto 0;
      background: #ddd;
      padding: 0;
      overflow: auto;
      cursor: crosshair;
    }

    #ctrl {
      width: 100%;
      max-width: 500px;
      margin: 10px auto;
      overflow: auto;
    }

    #ctrl button {
      display: block;
      width: 50%;
      float: left;
      margin: 0;
      padding: 20px;
      font-size: 100%;
    }

    #writingGrid div {
      width: 3.5714%; /* 1/28th */
      padding-top: 3.5714%;
      min-height: 5px;
      border: 1px solid #555;
      box-sizing: border-box;
      float: left;
    }

    .gridOff {
      opacity: 0.5;
    }

    .cellOn {
      background: #333;
    }
  </style>
</head>
<body>
<div id="writingGrid" class="gridOff"></div>
<div id="ctrl">
  <button id="resetGrid" disabled>Clear</button>
  <button id="predict" disabled>Predict</button>
</div>

<script>
  var math = window.math;
  var canvas = document.getElementById('writingGrid');
  for (var i = 0, len = 28 * 28; i < len; i++) {
    var cell = document.createElement('div');
    canvas.appendChild(cell);
  }

  var mouseDown = false;
  var className = 'cellOn';

  function mapGrid(cb) {
    var map = [];
    for (var i = 0, len = canvas.childElementCount; i < len; i++) {
      map.push(cb(canvas.children[i]));
    }
    return map;
  }

  function resetGrid() {
    mapGrid(function(cell) {
      cell.classList.remove(className);
    });
  }

  function predToInt(vals) {
    let max = 0;
    let maxIndex = 0;
    vals.forEach((val, index) => {
      if (val > max) {
        max = val;
        maxIndex = index;
      }
    });
    return maxIndex;
  }

  function predict() {
    var features = mapGrid(function(cell) {
      return cell.classList.contains(className) ? 1 : 0;
    });

    var prediction = math.softmaxMat(math.addMatVec(math.mulMat([features], weights), biases));
    var value = predToInt(prediction[0]);
    alert('You drew number: ' + value);
  }

  var weights = [];
  var biases = [];
  var resetBtn = document.getElementById('resetGrid');
  var predictBtn = document.getElementById('predict');

  function stroke(cell, off) {
    var action = off ? 'remove' : 'add';
    canvas.childNodes.forEach(function(node, index) {
      if (node === cell) {
        var offsets = [-28, +28, -1, +1, 0];
        offsets.forEach(function(offset) {
          var c = canvas.childNodes.item(index + offset);
          if (c) {
            c.classList[action](className);
          }
        });
      }
    });
  }

  function init(coefs) {
    fetch(coefs)
      .then(function(res) {
        return res.json();
      }).then(function(json){
        weights = json.weights;
        biases = json.bias;
      })
      .then(function(){
        canvas.addEventListener('dblclick', function (event) {
          stroke(event.target, true);
        });
        canvas.addEventListener('mousedown', function (event) {
          mouseDown = true;
          stroke(event.target);
        });
        canvas.addEventListener('mouseup', function () {
          mouseDown = false;
        });
        canvas.addEventListener('mousemove', function (event) {
          if (mouseDown) {
            stroke(event.target);
          }
        });

        resetBtn.addEventListener('click', resetGrid);
        predictBtn.addEventListener('click', predict);

        resetBtn.removeAttribute('disabled');
        predictBtn.removeAttribute('disabled');
        canvas.classList.remove('gridOff');
      });
  }

  init('/handwriting/coefs-40k.json');
</script>
</body>
</html>
